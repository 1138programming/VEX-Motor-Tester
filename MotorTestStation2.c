#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl2,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  I2CEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           TestMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rps = 0; // Float that records the final rotations per second (rps) of the motor. It has to be a float because it is an average and is not always a whole number.
int iterations = 5; //
float rpsReadings[5] = {0, 0, 0, 0, 0}; // Array to store the results of each of five tests performed on the motor, the results of which are averaged into the motor's rps
string type = ""; //
string IME = ""; // String displayed on the LCD containing information about the IME on the motor being tested
int lcdState = 0; // Keeps track of the LCD state, which determines what to display on the LCD
string offset = 0; // Stores the offset between the IME on the motor being tested and the shaft encoder

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

// Averages the speed between five tests in order to minimize error from the encoder
void average()
{
	rps = 0; // Resets speed

	for (int i = 0; i < 5; i++) // For loop to add up the values from each test
		rps += abs(rpsReadings[i]);

	offset = abs(round(rps - getMotorEncoder(TestMotor))); // Gets the offset between the IME on the motor being tested and the shaft encoder
	rps /= 5; // Divides the rps by five to finish getting an average
}

// Pauses the program until no LCD buttons are pressed
void waitForRelease()
{
	while (nLCDButtons != 0){}
	wait1Msec(5);
}

// Pauses the program until any LCD buttons are pressed
void waitForPress()
{
	while (nLCDButtons == 0){}
	wait1Msec(5);
}

// Function that performs five tests on the motor, each lasting one second, to measure its rps
void getMotorType()
{
	iterations = 0;
	motor[TestMotor] = 127;
	clearTimer(T1);
	SensorValue(encoder) = 0;
	resetMotorEncoder(TestMotor);
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "Testing...");
	while (iterations != 5) {
		if (time1[T1] >= 1000) {
			rpsReadings[iterations] = SensorValue[encoder];
			iterations++;
			clearTimer(T1);
			SensorValue(encoder) = 0;
		}
	}
	motor[TestMotor] = 0;
	average();
	if(rps > 0 && rps <= 799)
		type = "Torque";
	else if(rps >= 800 & rps <= 1199)
		type = "Speed";
	else if(rps >= 1200)
		type = "Turbo";
	else
		type = "NA";
	if(abs(getMotorEncoder(TestMotor)) > 0)
		IME = "<--IME: Found-->";
	else
		IME = "<-- IME: 404";
	wait1Msec(5);
	lcdState = 1;
}

task main()
{
	clearTimer(T1);
	clearTimer(T2);
	resetMotorEncoder(TestMotor);
	while (true)
	{
		clearLCDLine(0);
		clearLCDLine(1);
		switch (lcdState) {
			case 0:
				displayLCDCenteredString(0, "Center Button to");
				if (type == "")
					displayLCDCenteredString(1, "Test");
				else
					displayLCDString(1, 4, "--Test-Info>");
				waitForPress();
				if (nLCDButtons == rightButton && type != "") {
					waitForRelease();
					lcdState++;
				} else if (nLCDButtons == centerButton) {
					waitForRelease();
					getMotorType();
				}
				break;
			case 1:
				displayLCDCenteredString(0, type);
				displayLCDString(1, 0, IME);
				waitForPress();
				if (nLCDButtons == rightButton && IME == "<--IME: Found-->") {
					waitForRelease();
					lcdState++;
			  } else if (nLCDButtons == leftButton) {
			  	waitForRelease();
					lcdState--;
				} else if (nLCDButtons == centerButton) {
					waitForRelease();
					getMotorType();
				}
				break;
			case 2:
				displayLCDCenteredString(0, "IME Offset:");
				displayLCDCenteredString(1, offset);
				if (nLCDButtons == leftButton || IME != "<--IME: Found-->") {
					waitForRelease();
					lcdState--;
				} else if (nLCDButtons == centerButton) {
					waitForRelease();
					getMotorType();
				}
				break;
		}
	}
}
